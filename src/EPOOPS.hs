{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE QuasiQuotes                #-}
{-# LANGUAGE TemplateHaskell            #-}

module EPOOPS
    ( -- * Main methods
      withOPSSession,
      epoRequest,
      getEPODOCInstances,
      downloadEPODOCInstance,
      getEPODOCFullPlainText,
      getEPODOCBibliography,
      getEPODOCAbstractPlainText,
      getEPODOCDescriptionPlainText,
      getEPODOCClaimsPlainText,
      -- * Types
      OPSSession,
      OPSService (..),
      Bibliography (..),
      CPCCode (..),
      Credentials (..),
      InstanceListing,
      LogLevel (..),
      PageProgress,
      -- * Default
      silentProgress
    )
    where

import           Control.Arrow
import           Control.Lens       hiding ((&))
import           Data.Aeson.Lens
import qualified Data.ByteString    as B
import           Data.String.Here
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import           EPODOC
import           Lib.Prelude
import qualified Network.Wreq       as Wreq
import           System.IO.Streams  (fromLazyByteString)
import qualified System.IO.Streams  as S
import qualified System.IO.Temp     as Temp
import qualified Text.Parsec        as Parsec
import           Text.Printf        (printf)
import           Text.Read          (readMaybe)
import qualified Turtle             hiding ((<>))

import qualified Data.Map.Strict    as Map
import qualified Text.XML           as XML
import           Text.XML.Cursor    (($//), (>=>), (&//), ($/))
import qualified Text.XML.Cursor    as XML
import qualified Control.Monad.Catch as Catch
import Data.Maybe (fromJust)

import Control.Monad.Logger

opsEndPoint :: [Char]
opsEndPoint = "https://ops.epo.org/3.1"

newtype OAuth2Token = OAuth2Token { _rawtoken :: B.ByteString } deriving (Show, Eq)

-- | Represents an authenticated session with EPO OPS
newtype OPSSession a = OPSSession {
  runOPSSession :: LoggingT (ReaderT Credentials (StateT SessionState IO)) a
} deriving (Applicative, Functor, Monad, MonadIO, MonadReader Credentials, MonadState SessionState, Catch.MonadThrow, Catch.MonadCatch, Catch.MonadMask, MonadLogger)

-- | Stores credentials for EPO OPS system. Anonymous access is not supported.
-- Once you register with https://developers.epo.org for an EPO OPS account, consumer and secret keys
-- are generated by going to "My Apps" and creating a new application.
data Credentials = Credentials {
  consumerKey :: [Char],
  secretKey   :: [Char]
}

data SessionState = SessionState {quotaState :: Quotas, tokenState :: Maybe OAuth2Token}

data OPSServiceState = Idle | Busy | Overloaded deriving (Eq, Ord, Show)
data OPSServiceTraffic = Green | Yellow | Red | Black deriving (Eq, Ord, Show)
data OPSServiceQuota = RetrievalQuota | SearchQuota | INPADOCQuota | ImagesQuota | OtherQuota deriving (Eq, Ord, Show)

-- | Enumerates the different types of EPO OPS services currently supported.
data OPSService = Biblio | Abstract | FullCycle | FullText | Description | Claims | Equivalents | Images
  deriving (Eq, Ord, Show)

type Quotas = (OPSServiceState, Map OPSServiceQuota (OPSServiceTraffic, Int))

-- | A given EPODOC may have multiple published instances that correspond to it, typically when a
-- kind code is not provided. Each instance has page count and its down EPODOC, typically with a kind code
-- attached.  This is needed to retrieve all pages of the document into a PDF.
type InstanceListing = (Int, EPODOC)


formatAsEPODOCstring :: EPODOC -> [Char]
formatAsEPODOCstring = convertString . formatAsEPODOC

formatAsDOCDBstring :: EPODOC -> [Char]
formatAsDOCDBstring = convertString . formatAsDOCDB


-- 'idle (images=green:200, inpadoc=green:60, other=green:1000, retrieval=green:200, search=green:30)'
maxQuota :: OPSServiceQuota -> Int
maxQuota RetrievalQuota = 200
maxQuota SearchQuota = 30
maxQuota INPADOCQuota = 60
maxQuota ImagesQuota = 200
maxQuota OtherQuota = 1000

initialState :: SessionState
initialState = SessionState
                (Idle, Map.fromList [
                (RetrievalQuota, (Green, 200)),
                (SearchQuota, (Green, 30)),
                (INPADOCQuota, (Green, 60)),
                (ImagesQuota, (Green, 200)),
                (OtherQuota, (Green, 1000))])
                Nothing

-- | Queries to the EPO OPS service may be initiated from within the OPSSession monadic region,
-- which is established by this function.
-- Query rate is monitored and may be throttled based on EPO OPS responses on load level and
-- quota available.
-- The LogLevel parameter is used to specify the minimum Control.Monad.Logger.LogLevel which will be reported to
-- StdErr.
withOPSSession :: Credentials -> LogLevel -> OPSSession a -> IO (a, SessionState)
withOPSSession credentials minLevel k = runStateT (runReaderT (runStderrLoggingT (filterLogger logFilter (runOPSSession k))) credentials) initialState where
  logFilter _ level = level >= minLevel

authenticate :: OPSSession OAuth2Token
authenticate = do
  sessionState <- get
  settings <- ask
  let token = tokenState sessionState
      client_id = consumerKey settings
      client_secret = secretKey settings
  case token of
      Just t -> return t
      Nothing -> do
        $(logInfo) "Getting OAuth2 token"
        newtoken <- liftIO $ requestOAuthToken client_id client_secret
        put sessionState {tokenState = Just newtoken}
        return newtoken


potentiallyThrottle :: OPSService -> OPSSession ()
potentiallyThrottle service = do
  quota <- quotaState <$> get
  let quotaType = opsServiceToServiceQuota service
      (trafficLight, requests) = fromMaybe (Black, 0) $
                                    Map.lookup  quotaType
                                    (snd quota)
      serviceStatus = fst quota
  delayForServiceStatus serviceStatus
  delayForTrafficLight trafficLight
  delayForRate quotaType requests

delayForServiceStatus :: OPSServiceState -> OPSSession ()
delayForServiceStatus Overloaded = do
    $(logWarn) "System: Overloaded."
    liftIO $ threadDelay $ 2 * 1000

delayForServiceStatus Busy = do
    $(logInfo) "System: Busy."
    liftIO $ threadDelay 100

delayForServiceStatus Idle = do
  $(logDebug) "System: Idle."
  return ()

delayForTrafficLight :: OPSServiceTraffic -> OPSSession ()
delayForTrafficLight Black = do
  $(logWarn) "Service Traffic: Black"
  liftIO $ threadDelay $ 60 * 1000

delayForTrafficLight Red = do
  $(logWarn) "Service Traffic: Red"
  liftIO $ threadDelay $ 30 * 1000

delayForTrafficLight Yellow = do
  $(logInfo) "Service Traffic: Yellow"
  liftIO $ threadDelay $ 10 * 1000

delayForTrafficLight Green = do
  $(logDebug) "Service Traffic: Green"
  return ()

delayForRate :: OPSServiceQuota -> Int -> OPSSession ()
delayForRate service rate = do
  let maxRate = maxQuota service
      delay = floor $ (((60.0/fromIntegral rate) - (60.0/fromIntegral maxRate)) * 1000.0 :: Double)
      percent :: Int
      percent = floor ((fromIntegral rate :: Double) / (fromIntegral maxRate :: Double) * 100)
  $(logDebug) [i|Service quota at ${percent}%. Delaying ${delay} milliseconds|]
  liftIO $ threadDelay delay

updateThrottling :: Text -> OPSSession ()
updateThrottling rawThrottle = do
  sessionState <- get
  throttle <- parseThrottleStatement rawThrottle
  $(logDebug) [i|rawThrottle: '${rawThrottle}'|]
  $(logDebug) [i|parsedThrottle: '${throttle}'|]
  put sessionState {quotaState = throttle}

-- | Main function for requesting data from the EPO OPS system. An EPODOC and
-- an OPSService type are required, and an XML.Document type is returned with the raw
-- XML response from the EPO OPS service.
epoRequest :: EPODOC -> OPSService -> OPSSession XML.Document
epoRequest epodoc service = do
  token <- authenticate
  potentiallyThrottle service
  let opts =  Wreq.defaults
            & Wreq.auth ?~ Wreq.oauth2Bearer (_rawtoken token)
      query = [i|${opsEndPoint}/rest-services/published-data/publication/${opsSearchString epodoc}/${opsServiceToEndPoint service}|]
  $(logDebug) [i|GET: ${query}|]
  r <- liftIO $ Wreq.getWith opts query
  let body = r ^. Wreq.responseBody
      xml = XML.parseLBS_ XML.def body
      rawThrottle :: Text
      rawThrottle = convertString $ r ^. Wreq.responseHeader "X-Throttling-Control"
  updateThrottling rawThrottle
  return xml

downloadEPODOCPageAsPDF :: EPODOC -> [Char] -> (CurrPage -> IO ()) -> Int -> OPSSession ()
downloadEPODOCPageAsPDF epodoc path progressFn page = do
  let imageLink = rebuildImageLink epodoc
      query = [i|${opsEndPoint}/rest-services/${imageLink}.pdf?Range=${page}|]
      epokey = (formatAsEPODOCstring epodoc) :: [Char]
      file = printf "%s/%s-%04d.pdf" path epokey page
  downloadFile query file
  liftIO $ progressFn page

downloadFile :: [Char] -> FilePath -> OPSSession ()
downloadFile url name = do
  token <- authenticate
  potentiallyThrottle Images
  let opts =  Wreq.defaults
            & Wreq.auth ?~ Wreq.oauth2Bearer (_rawtoken token)
  $(logDebug) [i|GET: ${url}|]
  r <- liftIO $ Wreq.getWith opts url
  output <- liftIO $ fromLazyByteString $ r ^. Wreq.responseBody
  liftIO $ S.withFileAsOutput name (S.connect output)
  let rawThrottle :: Text
      rawThrottle = convertString $ r ^. Wreq.responseHeader "X-Throttling-Control"
  updateThrottling rawThrottle

extractDescription :: [Char] -> XML.Document -> Text
extractDescription lang xml = T.intercalate (convertString $ ("\n" :: [Char])) descriptionElements where
  cursor = XML.fromDocument xml
  descriptionElements = cursor
    $// XML.laxElement "description"
      >=> XML.check (rightLang lang)
    &// XML.laxElement "p"
    &// XML.content

extractClaims :: [Char] -> XML.Document -> Text
extractClaims lang xml = T.intercalate (convertString $ ("\n" :: [Char])) claimsElements where
  cursor = XML.fromDocument xml
  claimsElements = cursor
    $// XML.laxElement "claims"
      >=> XML.check (rightLang lang)
    &// XML.laxElement "claim-text"
    &// XML.content

rightLang :: [Char] -> XML.Cursor -> Bool
rightLang lang cursor = languageAttr == languageFilter where
  languageAttr = T.toLower $ headDef "" (XML.attribute "lang" cursor)
  languageFilter = T.toLower $ convertString lang

extractAbstract :: [Char] -> XML.Document -> Text
extractAbstract lang xml = T.intercalate (convertString $ ("\n" :: [Char])) abstractParas where
  cursor = XML.fromDocument xml
  abstractParas = cursor
    $// XML.laxElement "abstract"
      >=> XML.check (rightLang lang)
    &// XML.laxElement "p"
    &// XML.content


data CPCCode = CPCCode {
  cpcSection :: Text,
  cpcClass :: Text,
  cpcSubclass :: Text,
  cpcMainGroup :: Text,
  cpcSubgroup :: Text
} deriving (Show)

data Bibliography = Bibliography {
    epodocPubDate :: Date
,   epodocIPCs :: [Text]
,   epodocCPCs :: [CPCCode]
,   epodocAppDate :: Date
,   epodocAppEPODOC :: EPODOC
,   epodocPriorityDates :: [Date]
,   epodocPriorityEPODOCs :: [EPODOC]
,   epodocApplicants :: [Text]
,   epodocInventors :: [Text]
,   epodocTitle :: Text
,   epodocPatentCitations :: [EPODOC]
,   epodocAbstract :: Text
} deriving (Show)

formatFrontPage :: Bibliography -> Text
formatFrontPage bib = [i|
Title: ${epodocTitle bib}
Applicants: ${applicants}
Inventors: ${inventors}

ABSTRACT
${epodocAbstract bib}
|] where
  applicants = formatList $ epodocApplicants bib
  inventors = formatList $ epodocInventors bib
  formatList :: [Text] -> Text
  formatList items = T.intercalate ", " $ formatItem <$> items
  formatItem :: Text -> Text
  formatItem item = T.map clean item
  clean ' ' = ' '
  clean '\n' = ' '
  clean x = x

formatCPC :: XML.Cursor -> CPCCode
formatCPC cursor = CPCCode {
    cpcSection = section
  , cpcClass = class_
  , cpcSubclass = subclass
  , cpcMainGroup = mainGroup
  , cpcSubgroup = subGroup
  } where
    section = headDef "" $ cursor $/ XML.laxElement "section" &// XML.content
    class_ = headDef "" $  cursor $/ XML.laxElement "class" &// XML.content
    subclass = headDef "" $ cursor $/ XML.laxElement "subclass" &// XML.content
    mainGroup = headDef "" $ cursor $/ XML.laxElement "main-group" &// XML.content
    subGroup = headDef "" $ cursor $/ XML.laxElement "subgroup" &// XML.content

docdbXMLToEPODOC :: XML.Cursor -> EPODOC
docdbXMLToEPODOC cursor = EPODOC {
   countryCode = cc
,  serial = serialNo
,  kind = Just kindCode
, untrimmedSerial = Nothing
} where
  cc = headDef "" $ cursor $/ XML.laxElement "country" &// XML.content
  serialNo = headDef "" $ cursor $/ XML.laxElement "doc-number" &// XML.content
  kindCode = headDef "" $ cursor $/ XML.laxElement "kind" &// XML.content

type Date = Text



isCPC :: XML.Cursor -> Bool
isCPC cursor = T.toLower "CPC" == T.toLower scheme where
  scheme = headDef "" $ concat $ XML.attribute "scheme" <$> (cursor $/ XML.laxElement "classification-scheme")

getEPODOCBibliography :: [Char] -> EPODOC -> OPSSession Bibliography
getEPODOCBibliography lang epodoc = do
  rawBiblio <- epoRequest epodoc Biblio
  let
    cursor = XML.fromDocument rawBiblio
    pubDate = headDef "" $ cursor
      $// XML.laxElement "publication-reference"
      &// XML.laxElement "document-id"
        >=> XML.attributeIs "document-id-type" "epodoc"
      &// XML.laxElement "date"
      &// XML.content
    ipcs = cursor
      $// XML.laxElement "classification-ipc"
      &// XML.laxElement "text"
      &// XML.content
    cpcs = formatCPC <$> (cursor
      $// XML.laxElement "patent-classification"
        >=> XML.check isCPC)
    appDate = headDef "" $ cursor
      $// XML.laxElement "application-reference"
      &// XML.laxElement "document-id"
        >=> XML.attributeIs "document-id-type" "epodoc"
      &// XML.laxElement "date"
      &// XML.content
    appEPODOC = headMay $ docdbXMLToEPODOC <$> (cursor
      $// XML.laxElement "application-reference"
      &// XML.laxElement "document-id"
        >=> XML.attributeIs "document-id-type" "docdb")
    priorityDates = cursor
      $// XML.laxElement "priority-claim"
      &// XML.laxElement "document-id"
        >=> XML.attributeIs "document-id-type" "epodoc"
      &// XML.laxElement "date"
      &// XML.content
    priorityDocuments = EPODOC.parseToEPODOC <$> (cursor
      $// XML.laxElement "priority-claim"
      &// XML.laxElement "document-id"
        >=> XML.attributeIs "document-id-type" "epodoc"
      &// XML.laxElement "doc-number"
      &// XML.content)
    applicants = cursor
      $// XML.laxElement "applicant"
        >=> XML.attributeIs "data-format" "epodoc"
      &// XML.laxElement "name"
      &// XML.content
    inventors = cursor
      $// XML.laxElement "inventor"
        >=> XML.attributeIs "data-format" "epodoc"
      &// XML.laxElement "name"
      &// XML.content
    title = headMay $ cursor
      $// XML.laxElement "invention-title"
        >=> XML.check (rightLang lang)
      &// XML.content
    patentCitations :: [EPODOC]
    patentCitations = docdbXMLToEPODOC <$> (cursor
      $// XML.laxElement "patcit"
      &// XML.laxElement "document-id"
        >=> XML.attributeIs "document-id-type" "docdb")
    abstract = cursor
      $// XML.laxElement "abstract"
        >=> XML.check (rightLang lang)
      &// XML.laxElement "p"
      &// XML.content
  return Bibliography {
      epodocPubDate = pubDate
    , epodocIPCs = ipcs
    , epodocCPCs = cpcs
    , epodocAppDate = appDate
    , epodocAppEPODOC = fromJust appEPODOC
    , epodocPriorityDates = priorityDates
    , epodocPriorityEPODOCs = rights priorityDocuments
    , epodocApplicants = applicants
    , epodocInventors = inventors
    , epodocTitle = fromJust title
    , epodocAbstract = T.intercalate (convertString $ ("\n" :: [Char])) abstract
    , epodocPatentCitations = patentCitations
  }


getEPODOCFrontPagePlainText :: [Char] -> EPODOC -> OPSSession Text
getEPODOCFrontPagePlainText language epodoc = formatFrontPage <$> getEPODOCBibliography language epodoc

-- | Gets the abstract for an EPODOC from EPO OPS.
getEPODOCAbstractPlainText :: [Char] -> EPODOC -> OPSSession Text
getEPODOCAbstractPlainText language epodoc = extractAbstract language <$> epoRequest epodoc Abstract

-- | Gets the claims for an EPODOC from EPO OPS.
-- Note that EPO OPS only has the fulltext for the following authorities: EP, WO, AT, CH, GB, ES,  CA, and FR.
getEPODOCClaimsPlainText :: [Char] -> EPODOC -> OPSSession (Maybe Text)
getEPODOCClaimsPlainText language epodoc
  | countryCode epodoc `elem` ["EP", "WO", "AT", "CH", "GB", "ES", "CA", "FR"] = do
      claims <- extractClaims language <$> epoRequest epodoc Claims
      return (Just claims)
  | otherwise = return Nothing

-- | Gets the description of the description and claims for an EPODOC from EPO OPS.
-- Note that EPO OPS only has the fulltext for the following authorities: EP, WO, AT, CH, GB, ES,  CA, and FR.
getEPODOCDescriptionPlainText :: [Char] -> EPODOC -> OPSSession (Maybe Text)
getEPODOCDescriptionPlainText language epodoc
  | countryCode epodoc `elem` ["EP", "WO", "AT", "CH", "GB", "ES", "CA", "FR"] = do
      description <- extractDescription language <$> epoRequest epodoc Description
      return (Just description)
  | otherwise = return Nothing

-- | Gets the fulltext of the description and claims for an EPODOC from EPO OPS.
-- Note that EPO OPS only has the fulltext for the following authorities: EP, WO, AT, CH, GB, ES,  CA, and FR.
getEPODOCFullPlainText :: [Char] -> EPODOC -> OPSSession (Maybe Text)
getEPODOCFullPlainText language epodoc = do
  front <- getEPODOCFrontPagePlainText language epodoc
  description <- getEPODOCDescriptionPlainText language epodoc
  claims <- getEPODOCClaimsPlainText language epodoc
  case (description, claims) of
    (Just d, Just c) -> return $ Just $ [i|
${front}

DESCRIPTION
${d}

CLAIMS
${c}|]
    _ -> return Nothing

-- | Gets a list of Document Instances that correspond with a particular EPODOC. (See InstanceListing)
-- Strictness determines whether non-equivalent EPODOCs are returned (see EPODOC.equivEPODOC)
-- Note that some likely unwanted kind codes (notably EP A3 and EP A4 search reports) are excluded unless you were
-- specifically requesting them.
getEPODOCInstances :: Bool -> EPODOC -> OPSSession [InstanceListing]
getEPODOCInstances strictly epodoc = do
  imagedata <- epoRequest epodoc Images
  let rawinstances = getLinksAndCounts imagedata
      filteredInstances = filter allow rawinstances
      unwantedKind e (c, k) = countryCode e == c && (kind epodoc /= Just k && kind e == Just k)
      allow (l, e)
       | l <= 1 = False
       | strictly && not (e `equivEPODOC` epodoc) = False
       | e `unwantedKind` ("EP", "A3") = False -- exclude search reports, unless we ask for them
       | e `unwantedKind` ("EP", "A4") = False
       | otherwise = True
  $(logDebug) [i|Found ${length rawinstances} total instances. After filtering, ${length filteredInstances} are left.|]
  return filteredInstances

type TotalPages = Int
type CurrPage = Int

-- | A function taking total pages to be downloaded and current page being downloaded and doing something in IO, typically
-- to update the user.
type PageProgress = TotalPages -> CurrPage -> IO ()

-- | Convenience predefinition for silent PageProgress updates.
silentProgress :: PageProgress
silentProgress _ _ = return ()

-- | For a given InstanceListing, retrieves all individual pages from the EPO OPS system in PDF format.
-- These are stored into a temporary folder in the working directory of the calling process. After retrieval, the individual
-- PDF pages are joined together using a shell invocation of 'gs' (Ghostscript), which must be installed for this work.
-- The final PDF is stored in the working directory of the calling process, as ${EPODOC}.pdf format, and the temporary
-- directory is removed.
--
-- The first parameter, PageProgress, allows for easier progress reporting.
downloadEPODOCInstance :: PageProgress -> InstanceListing -> OPSSession ()
downloadEPODOCInstance progressFn (count, instanceEPODOC) = do
  let pages = [1..count]
      epokey :: [Char]
      epokey = formatAsEPODOCstring instanceEPODOC
      output :: [Char]
      output = [i|${epokey}.pdf|]
  _ <- Temp.withTempDirectory "." "pat-download." $ \tmpDir -> do
        mapM_ (downloadEPODOCPageAsPDF instanceEPODOC tmpDir (progressFn count)) pages
        liftIO $ Turtle.shell [i|gs -dBATCH -dNOPAUSE -q -sDEVICE=pdfwrite -sOutputFile=${output} "${tmpDir}"/*.pdf|] Turtle.empty
  return ()


requestOAuthToken :: [Char] -> [Char] -> IO OAuth2Token
requestOAuthToken client_id client_secret = do
    let opts = Wreq.defaults
            & Wreq.header "Accept" .~ ["application/json"]
            & Wreq.header "Content-Type" .~ ["application/x-www-form-urlencoded"]
    let body =
          [ "grant_type" Wreq.:= ("client_credentials" :: [Char])
          , "client_id" Wreq.:= client_id
          , "client_secret" Wreq.:= client_secret]
    resp <- Wreq.postWith opts (opsEndPoint <> "/auth/accesstoken") body
    let token = resp ^. Wreq.responseBody . key "access_token" . _String
    return $ (T.encodeUtf8 >>> OAuth2Token) token


opsSearchString :: EPODOC -> [Char]
opsSearchString epodoc = case kind epodoc of
  Nothing -> [i|epodoc/${formatAsEPODOCstring epodoc}|]
  Just _  -> [i|docdb/${formatAsDOCDBstring epodoc}|]

opsServiceToServiceQuota :: OPSService -> OPSServiceQuota
opsServiceToServiceQuota s
  | s == Images = ImagesQuota
  | otherwise = RetrievalQuota

opsServiceToEndPoint :: OPSService -> [Char]
opsServiceToEndPoint s
  | s == Biblio = "biblio"
  | s == Abstract = "abstract"
  | s == FullCycle = "full-cycle"
  | s == FullText = "full-text"
  | s == Description = "description"
  | s == Claims = "claims"
  | s == Equivalents = "equivalents"
  | s == Images = "images"
  | otherwise = notImplemented

opsServiceStateFromString :: [Char] -> OPSServiceState
opsServiceStateFromString "idle" = Idle
opsServiceStateFromString "busy" = Busy
opsServiceStateFromString _      = Overloaded

opsServiceTrafficFromString :: [Char] -> OPSServiceTraffic
opsServiceTrafficFromString "green"  = Green
opsServiceTrafficFromString "yellow" = Yellow
opsServiceTrafficFromString "red"    = Red
opsServiceTrafficFromString _        = Black

opsServiceQuotaFromString :: [Char] -> OPSServiceQuota
opsServiceQuotaFromString "retrieval" = RetrievalQuota
opsServiceQuotaFromString "search"    = SearchQuota
opsServiceQuotaFromString "inpadoc"   = INPADOCQuota
opsServiceQuotaFromString "images"    = ImagesQuota
opsServiceQuotaFromString _           = OtherQuota

readDef :: Read a => a -> [Char] -> a
readDef def input = fromMaybe def (readMaybe input)

throttleStatement :: Parsec.Parsec Text () Quotas
throttleStatement = do
  let service_state = do
        service_name <- Parsec.many1 Parsec.letter
        void $ Parsec.char '='
        traffic_light <- Parsec.many1 Parsec.letter
        void $ Parsec.char ':'
        request_limit <- Parsec.many1 Parsec.digit
        void $ Parsec.optional $ Parsec.char ','
        void $ Parsec.optional Parsec.spaces
        return (opsServiceQuotaFromString service_name, (opsServiceTrafficFromString traffic_light, readDef 0 request_limit))
  system_state <- Parsec.choice [Parsec.try $ Parsec.string "idle", Parsec.try $ Parsec.string "busy", Parsec.string "overloaded"]
  void Parsec.spaces
  services <- Parsec.between (Parsec.char '(') (Parsec.char ')') (Parsec.many1 service_state)
  let service_states = Map.fromList services
  return (opsServiceStateFromString system_state, service_states)

parseThrottleStatement :: Text -> OPSSession Quotas
parseThrottleStatement input = case Parsec.parse throttleStatement (convertString input) input of
    (Right result) -> return result
    (Left err) -> do
      $(logError) [i|X-Throttle parsing failure: ${err}|]
      return (Overloaded, Map.empty)

rebuildImageLink :: EPODOC -> [Char]
rebuildImageLink epodoc = printf "published-data/images/%s/%s/%s/fullimage"
                                  (convertString (countryCode epodoc)::[Char])
                                  (convertString (serial epodoc)::[Char])
                                  (convertString (fromMaybe "%" $ kind epodoc)::[Char])

imageLinktoEPODOC :: Text -> Maybe EPODOC
imageLinktoEPODOC imageLink = hush $ Parsec.parse opsImageFormat "opsImageFormat" imageLink where
  opsImageFormat :: Parsec.Parsec Text () EPODOC
  opsImageFormat = do
    void $ Parsec.string "published-data/images/"
    countryPart <- Parsec.count 2 Parsec.letter
    void $ Parsec.char '/'
    serialPart <- Parsec.many1 Parsec.digit
    void $ Parsec.char '/'
    kindPart <- Parsec.many1 (Parsec.letter <|> Parsec.digit)
    return $ EPODOC (convertString countryPart)
                    (convertString serialPart)
                    (Just (convertString kindPart))
                    Nothing

getLinksAndCounts :: XML.Document -> [InstanceListing]
getLinksAndCounts xml = catMaybes (getLinkAndCount <$> instances)
  where
    cursor = XML.fromDocument xml
    instances = cursor $// XML.laxElement "document-instance" >=> XML.attributeIs "desc" "FullDocument"
    getLinkAndCount instanceCursor =
      let
        instanceEPODOC = imageLinktoEPODOC $ headDef "" (XML.attribute "link" instanceCursor)
        pageCount = join $ (readMaybe . convertString) <$> headMay (XML.attribute "number-of-pages" instanceCursor)
      in case (pageCount, instanceEPODOC) of
          (Just pg, Just iEPODOC) -> Just (pg, iEPODOC)
          (_, _)            -> Nothing
